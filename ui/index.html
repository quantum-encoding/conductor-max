<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”± Conductor Max - Terminal Container</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://unpkg.com/xterm@5.3.0/css/xterm.css">
    <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://unpkg.com/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <div class="logo-icon">ğŸ”±</div>
            <h1>Conductor Max</h1>
            <div class="subtitle">Terminal Container</div>
        </div>
        <div class="header-controls">
            <button class="btn btn-primary" onclick="createNewTerminal()">
                <span class="btn-icon">â•</span>
                New Terminal
            </button>
            <div class="status-indicator">
                <div class="status-dot active"></div>
                <span id="terminal-count">0 terminals</span>
            </div>
        </div>
    </div>

    <!-- Terminal Tabs -->
    <div class="terminal-tabs" id="terminal-tabs">
        <!-- Tabs will be inserted here -->
    </div>

    <!-- Terminal Container -->
    <div class="terminal-container" id="terminal-container">
        <div class="welcome-screen" id="welcome-screen">
            <div class="welcome-content">
                <div class="welcome-icon">ğŸ”±</div>
                <h2>Welcome to Conductor Max</h2>
                <p>Professional terminal container for AI orchestration</p>
                <button class="btn btn-primary btn-large" onclick="createNewTerminal()">
                    <span class="btn-icon">âš¡</span>
                    Start Your First Terminal
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // ğŸ”± Conductor Max Terminal Container
        
        // Tauri API - CORRECT initialization pattern for v2
        let invoke;
        
        // Terminal Management
        let terminals = new Map();
        let activeTerminalId = null;
        let terminalCounter = 0;
        
        // XTerm.js addons - check for correct namespace
        const FitAddon = typeof window !== 'undefined' && window.FitAddon ? window.FitAddon : null;
        const WebLinksAddon = typeof window !== 'undefined' && window.WebLinksAddon ? window.WebLinksAddon : null;
        
        // Initialize Tauri API - CORRECT for v2.x
        function initializeTauri() {
            if (window.__TAURI__ && window.__TAURI__.core && window.__TAURI__.core.invoke) {
                invoke = window.__TAURI__.core.invoke;
                console.log('âœ… Tauri v2 API initialized correctly');
                return true;
            } else {
                console.warn('âš ï¸ Tauri API not available yet');
                return false;
            }
        }
        
        // Terminal Management Functions
        async function createNewTerminal() {
            console.log('ğŸ”± createNewTerminal() called');
            
            if (!invoke) {
                console.error('âŒ Tauri API not available');
                alert('Tauri API not available. Check console for details.');
                return;
            }
            
            try {
                terminalCounter++;
                const terminalId = `terminal-${terminalCounter}`;
                const terminalName = `Terminal ${terminalCounter}`;
                
                console.log(`ğŸ”± Creating new terminal: ${terminalId}`);
                
                // Spawn PTY terminal via Tauri
                const agentId = await invoke('spawn_agent', {
                    agentType: 'bash',
                    apiKey: '',
                    agentId: terminalId,
                    workspacePath: null
                });
                
                console.log(`âœ… PTY spawned with ID: ${agentId}`);
                
                // Create terminal UI
                createTerminalUI(terminalId, terminalName, agentId);
                
                // Initialize XTerm
                initializeXTerm(terminalId, agentId);
                
                // Switch to new terminal
                switchToTerminal(terminalId);
                
                updateTerminalCount();
                hideWelcomeScreen();
                
            } catch (error) {
                console.error('âŒ Failed to create terminal:', error);
                showNotification('Failed to create terminal: ' + error, 'error');
            }
        }
        
        function createTerminalUI(terminalId, terminalName, agentId) {
            // Create tab
            const tabsContainer = document.getElementById('terminal-tabs');
            const tab = document.createElement('div');
            tab.className = 'terminal-tab';
            tab.id = `tab-${terminalId}`;
            tab.onclick = () => switchToTerminal(terminalId);
            
            tab.innerHTML = `
                <span class="terminal-tab-icon">âš¡</span>
                <span class="terminal-tab-title">${terminalName}</span>
                <span class="terminal-tab-close" onclick="event.stopPropagation(); closeTerminal('${terminalId}')">Ã—</span>
            `;
            
            tabsContainer.appendChild(tab);
            
            // Create terminal instance
            const container = document.getElementById('terminal-container');
            const instance = document.createElement('div');
            instance.className = 'terminal-instance';
            instance.id = `instance-${terminalId}`;
            
            instance.innerHTML = `
                <div class="terminal-wrapper">
                    <div class="terminal-loading">Loading terminal...</div>
                    <div class="xterm-container" id="xterm-${terminalId}" style="display: none; width: 100%; height: 100%;"></div>
                </div>
            `;
            
            container.appendChild(instance);
            
            // Store terminal data
            terminals.set(terminalId, {
                id: terminalId,
                name: terminalName,
                agentId: agentId,
                xterm: null,
                fitAddon: null,
                active: false
            });
        }
        
        function initializeXTerm(terminalId, agentId) {
            const terminalData = terminals.get(terminalId);
            if (!terminalData) return;
            
            try {
                // Create XTerm instance
                const xterm = new Terminal({
                    fontFamily: '"Fira Code", "SF Mono", Monaco, "Cascadia Code", monospace',
                    fontSize: 14,
                    lineHeight: 1.4,
                    cursorBlink: true,
                    cursorStyle: 'block',
                    theme: {
                        background: 'hsl(220, 20%, 8%)',
                        foreground: 'hsl(220, 15%, 90%)',
                        cursor: 'hsl(25, 20%, 55%)',
                        selection: 'hsla(25, 20%, 55%, 0.3)',
                        black: '#2e3440',
                        red: '#bf616a',
                        green: '#a3be8c',
                        yellow: '#ebcb8b',
                        blue: '#81a1c1',
                        magenta: '#b48ead',
                        cyan: '#88c0d0',
                        white: '#e5e9f0',
                        brightBlack: '#4c566a',
                        brightRed: '#bf616a',
                        brightGreen: '#a3be8c',
                        brightYellow: '#ebcb8b',
                        brightBlue: '#81a1c1',
                        brightMagenta: '#b48ead',
                        brightCyan: '#8fbcbb',
                        brightWhite: '#eceff4'
                    }
                });
                
                // Create and load addons
                let fitAddon = null;
                try {
                    if (FitAddon) {
                        fitAddon = new FitAddon();
                        xterm.loadAddon(fitAddon);
                        console.log('âœ… FitAddon loaded');
                    } else {
                        console.warn('âš ï¸ FitAddon not available');
                    }
                } catch (error) {
                    console.error('âŒ FitAddon error:', error);
                }
                
                try {
                    if (WebLinksAddon) {
                        const webLinksAddon = new WebLinksAddon();
                        xterm.loadAddon(webLinksAddon);
                        console.log('âœ… WebLinksAddon loaded');
                    } else {
                        console.warn('âš ï¸ WebLinksAddon not available');
                    }
                } catch (error) {
                    console.error('âŒ WebLinksAddon error:', error);
                }
                
                // Open terminal in container
                const container = document.getElementById(`xterm-${terminalId}`);
                xterm.open(container);
                
                // Fit to container
                if (fitAddon) {
                    setTimeout(() => fitAddon.fit(), 100);
                }
                
                // Handle user input
                xterm.onData(data => {
                    if (invoke && agentId) {
                        sendToTerminal(agentId, data);
                    }
                });
                
                // Update terminal data
                terminalData.xterm = xterm;
                terminalData.fitAddon = fitAddon;
                
                // Start output polling
                startOutputPolling(terminalId, agentId, xterm);
                
                // Hide loading, show terminal
                const loadingEl = container.parentElement.querySelector('.terminal-loading');
                if (loadingEl) loadingEl.style.display = 'none';
                container.style.display = 'block';
                
                console.log(`âœ… XTerm initialized for ${terminalId}`);
                
            } catch (error) {
                console.error('âŒ Failed to initialize XTerm:', error);
                showNotification('Failed to initialize terminal UI: ' + error, 'error');
            }
        }
        
        async function sendToTerminal(agentId, data) {
            if (!invoke) return;
            
            try {
                // Convert string to bytes for raw sending
                const encoder = new TextEncoder();
                const bytes = Array.from(encoder.encode(data));
                
                await invoke('send_raw_to_agent', {
                    agentId: agentId,
                    data: bytes
                });
            } catch (error) {
                console.error('âŒ Failed to send to terminal:', error);
            }
        }
        
        function startOutputPolling(terminalId, agentId, xterm) {
            const pollOutput = async () => {
                if (!invoke || !terminals.has(terminalId)) return;
                
                try {
                    const output = await invoke('get_agent_output', {
                        agentId: agentId
                    });
                    
                    if (output && output.length > 0) {
                        // Convert bytes back to string
                        const decoder = new TextDecoder();
                        const text = decoder.decode(new Uint8Array(output));
                        xterm.write(text);
                    }
                } catch (error) {
                    // Suppress frequent polling errors
                    if (error.toString().includes('Agent') && error.toString().includes('not found')) {
                        // Terminal was likely closed
                        return;
                    }
                    console.debug('Output polling error:', error);
                }
                
                // Continue polling if terminal is still active
                if (terminals.has(terminalId)) {
                    setTimeout(pollOutput, 50); // 20 FPS polling
                }
            };
            
            setTimeout(pollOutput, 100);
        }
        
        function switchToTerminal(terminalId) {
            // Update active terminal
            activeTerminalId = terminalId;
            
            // Update tabs
            document.querySelectorAll('.terminal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${terminalId}`)?.classList.add('active');
            
            // Update instances
            document.querySelectorAll('.terminal-instance').forEach(instance => {
                instance.classList.remove('active');
            });
            document.getElementById(`instance-${terminalId}`)?.classList.add('active');
            
            // Focus terminal and resize
            const terminalData = terminals.get(terminalId);
            if (terminalData && terminalData.xterm) {
                terminalData.xterm.focus();
                
                // Resize after a short delay to ensure proper dimensions
                if (terminalData.fitAddon) {
                    setTimeout(() => {
                        terminalData.fitAddon.fit();
                        
                        // Send resize to backend
                        if (invoke) {
                            const { cols, rows } = terminalData.xterm;
                            invoke('resize_agent_terminal', {
                                agentId: terminalData.agentId,
                                cols: cols,
                                rows: rows
                            }).catch(console.error);
                        }
                    }, 100);
                }
            }
        }
        
        async function closeTerminal(terminalId) {
            const terminalData = terminals.get(terminalId);
            if (!terminalData) return;
            
            try {
                // Kill the agent
                if (invoke && terminalData.agentId) {
                    await invoke('kill_agent', {
                        agentId: terminalData.agentId
                    });
                }
                
                // Clean up XTerm
                if (terminalData.xterm) {
                    terminalData.xterm.dispose();
                }
                
                // Remove UI elements
                document.getElementById(`tab-${terminalId}`)?.remove();
                document.getElementById(`instance-${terminalId}`)?.remove();
                
                // Remove from terminals map
                terminals.delete(terminalId);
                
                // Switch to another terminal or show welcome
                if (activeTerminalId === terminalId) {
                    const remainingTerminals = Array.from(terminals.keys());
                    if (remainingTerminals.length > 0) {
                        switchToTerminal(remainingTerminals[0]);
                    } else {
                        activeTerminalId = null;
                        showWelcomeScreen();
                    }
                }
                
                updateTerminalCount();
                
                console.log(`âœ… Terminal ${terminalId} closed`);
                
            } catch (error) {
                console.error('âŒ Failed to close terminal:', error);
            }
        }
        
        function updateTerminalCount() {
            const count = terminals.size;
            const countEl = document.getElementById('terminal-count');
            if (countEl) {
                countEl.textContent = `${count} terminal${count !== 1 ? 's' : ''}`;
            }
            
            const statusDot = document.querySelector('.status-dot');
            if (statusDot) {
                statusDot.classList.toggle('active', count > 0);
            }
        }
        
        function hideWelcomeScreen() {
            const welcomeScreen = document.getElementById('welcome-screen');
            if (welcomeScreen) {
                welcomeScreen.style.display = 'none';
            }
        }
        
        function showWelcomeScreen() {
            const welcomeScreen = document.getElementById('welcome-screen');
            if (welcomeScreen) {
                welcomeScreen.style.display = 'flex';
            }
        }
        
        function showNotification(message, type = 'info') {
            console.log(`${type.toUpperCase()}: ${message}`);
            // Could implement toast notifications here
        }
        
        // Window resize handling
        window.addEventListener('resize', () => {
            if (activeTerminalId) {
                const terminalData = terminals.get(activeTerminalId);
                if (terminalData && terminalData.fitAddon) {
                    setTimeout(() => {
                        terminalData.fitAddon.fit();
                    }, 100);
                }
            }
        });
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ğŸ”± Conductor Max Terminal Container initializing...');
            
            // Try to initialize Tauri with retries
            let initialized = false;
            for (let i = 0; i < 20; i++) {
                initialized = initializeTauri();
                if (initialized) break;
                
                if (i % 5 === 0) {
                    console.log(`Waiting for Tauri API... attempt ${i + 1}/20`);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (initialized && invoke) {
                console.log('âœ… Conductor Max ready!');
            } else {
                console.error('âŒ Could not initialize Tauri API');
                showNotification('Failed to initialize Tauri API', 'error');
            }
            
            updateTerminalCount();
        });
        
        console.log('ğŸ”± Conductor Max Terminal Container loaded');
    </script>
</body>
</html>